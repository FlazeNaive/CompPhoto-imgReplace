import numpy as np
import cv2

def replaceTile(canvas, tile):
    """
    function for replacing the tile generated by diffvg
    the tile is a rotatable rectangle, and the rotation center is the topleft corner of the canvas

    what we will do is perform the rotation but maintain the center of the tile

    canvas: the image to paint
    tile: shape(w, h), pos(x, y), rotate(theta), fill(color) 
    """
    # get rotation matrix
    M = cv2.getRotationMatrix2D((0, 0), tile.rotate, 1)

    # get the vertieces of the tile
    vertices = np.array([[tile.pos[0], tile.pos[1]], [tile.pos[0] + tile.shape[0], tile.pos[1]], [tile.pos[0] + tile.shape[0], tile.pos[1] + tile.shape[1]], [tile.pos[0], tile.pos[1] + tile.shape[1]]], dtype=np.float32)
    print(vertices)
    
    # rotate the vertieces
    vertices = cv2.transform(vertices.reshape(1, -1, 2), M).reshape(-1, 2)
    print(vertices)

    # paint the rotated rectangle by FillPoly
    cv2.fillPoly(canvas, [vertices.astype(np.int32)], tile.fill)



class Tile:
    """
    class for storing the tile information
    """
    def __init__(self, shape, pos, rotate, fill):
        self.shape = shape
        self.pos= pos
        self.rotate = rotate
        self.fill = fill

# test function replaceTile
if __name__ == "__main__":
    # create a canvas
    canvas = np.zeros((500, 500, 3), dtype=np.uint8)

    # create a tile
    tile = Tile((100, 100), (100, 0), -45, (255, 0, 0))

    # paint the tile
    cv2.rectangle(canvas, (tile.pos[0], tile.pos[1]), (tile.pos[0] + tile.shape[0], tile.pos[1] + tile.shape[1]), tile.fill, -1)
    cv2.imwrite("origin.png", canvas)

    canvas = np.zeros((500, 500, 3), dtype=np.uint8)

    # replace the tile
    replaceTile(canvas, tile)

    # show the canvas
    # cv2.imshow("canvas", canvas)
    # cv2.waitKey(0)
    # cv2.destroyAllWindows()

    cv2.imwrite("canvas.png", canvas)