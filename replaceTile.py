import numpy as np
import cv2

def rotate_image(canvas, image, tile): 
    pos = tile.pos
    angle = tile.rotate
    rotation_centor = (0, 0)
    rot_mat = cv2.getRotationMatrix2D(rotation_centor, angle, 1.0)

    canvas_sized_image = np.zeros((canvas.shape[0], canvas.shape[1], 3), dtype=np.uint8)
    mask = np.zeros((canvas.shape[0], canvas.shape[1]), dtype=np.uint8)

    for x in range(image.shape[0]):
        for y in range(image.shape[1]):
            try:
                canvas_sized_image[x + pos[1], y + pos[0]] = image[x, y]
                mask[x+pos[1], y+pos[0]] = 255
            except:
                pass

    cv2.imwrite("output/canvas_sized_image.png", canvas_sized_image)
    result = cv2.warpAffine(canvas_sized_image, rot_mat, canvas_sized_image.shape[1::-1], flags=cv2.INTER_LINEAR)
    mask = cv2.warpAffine(mask, rot_mat, canvas_sized_image.shape[1::-1], flags=cv2.INTER_LINEAR)
    cv2.imwrite("output/rotated_img.png", result)

    for x in range(result.shape[0]):
        for y in range(result.shape[1]):
            try:
                if mask[x, y] == 255:
                    canvas[x, y] = result[x, y]
            except:
                pass

    cv2.imwrite("output/result.png", canvas)
    return canvas

def replaceTile(canvas, tile):
    """
    function for replacing the tile generated by diffvg
    the tile is a rotatable rectangle, and the rotation center is the topleft corner of the canvas

    what we will do is perform the rotation but maintain the center of the tile

    canvas: the image to paint
    tile: shape(w, h), pos(x, y), rotate(theta), fill(color) 
    """
    # get rotation matrix
    M = cv2.getRotationMatrix2D((0, 0), tile.rotate, 1)

    # get the vertieces of the tile
    vertices = np.array([[tile.pos[0], tile.pos[1]], [tile.pos[0] + tile.shape[0], tile.pos[1]], [tile.pos[0] + tile.shape[0], tile.pos[1] + tile.shape[1]], [tile.pos[0], tile.pos[1] + tile.shape[1]]], dtype=np.float32)
    print(vertices)
    
    # rotate the vertieces
    vertices = cv2.transform(vertices.reshape(1, -1, 2), M).reshape(-1, 2)
    print(vertices)

    # paint the rotated rectangle by FillPoly
    cv2.fillPoly(canvas, [vertices.astype(np.int32)], tile.fill)


class Tile:
    """
    class for storing the tile information
    """
    def __init__(self, shape, pos, rotate, fill):
        self.shape = shape
        self.pos= pos
        self.rotate = rotate
        self.fill = fill


#==================== test function ====================
def tile_array(tile):
    # create a image for the tile
    tile_img = np.zeros((tile.shape[0], tile.shape[1], 3), dtype=np.uint8)
    # fill the image with tile's color
    tile_img[:] = tile.fill
    # make it gradient
    for x in range(tile.shape[0]) :
        for y in range(tile.shape[1]): 
            tile_img[x, y] = tile_img[x, y] * (x / tile.shape[0]) 
    return tile_img


def test_rotate_image(canvas, tile):
    
    tile_img = cv2.resize(cv2.imread("target.png"), (tile.shape[0], tile.shape[1]))

    # rotate the tile
    tile_img = rotate_image(canvas, tile_img, tile)
    cv2.imwrite("output/tile-rotated.png", tile_img)

def test_replace_tile(canvas, tile):
    # paint the tile
    cv2.rectangle(canvas, (tile.pos[0], tile.pos[1]), (tile.pos[0] + tile.shape[0], tile.pos[1] + tile.shape[1]), tile.fill, -1)
    cv2.imwrite("output/origin.png", canvas)

    canvas = np.zeros(canvas.shape, dtype=np.uint8)

    # replace the tile
    replaceTile(canvas, tile)

    cv2.imwrite("output/canvas.png", canvas)


# test function replaceTile
if __name__ == "__main__":
    # create a canvas
    canvas = np.zeros((500, 1000, 3), dtype=np.uint8)
    canvas = cv2.resize(cv2.imread("emptycanvas.png"), (canvas.shape[1], canvas.shape[0]))
    # create a tile
    tile = Tile((100, 100), (100, 0), -45, (255, 0, 0))

    test_rotate_image(canvas, tile)
    test_replace_tile(canvas, tile)